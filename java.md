### Java

* Java集合体系
    - Set(集)
        + 不区分元素的顺序，不允许相同元素
        + 存入：只能存Set中没有的元素，存入的元素会按照内部的排序规则排好
        + 取出：不能取出具体位置的元素，只能用Iterator取得所有元素
    - List（列表）
        + 区分元素的顺序，允许相同元素
        + LinkedList比ArrayList便于频繁的修改操作
        + 存入：位置按照存入的顺序，也可以在某个位置插入
        + 取出：Iterator遍历所有元素，或者取出某个位置的元素
    - Map（映射）
        + key(键) - value(值)
        + key不能相同
        + 存入：每次都是key-value一对值存入，key不可以重复，
        + 取出：Iterator遍历所有元素，根据key得到对应的value
    - 集合只保存引用数据类型
    - 所有的集合体系都实现了Collection接口

* 抽象类(abstract)与接口(interface)

    |      | abstract class | interface|
    |:----:|:--------------:|:--------:|
    | 修饰词 | 不能有final | 只有public |
    | 属性 | 没有private | public静态常量 |
    | 构造方法 | 可有可无 | 没有 |
    | 普通方法 | 可以有具体方法 | 必须是public abstract方法，JDK8出现default方法 |
    | 子类 | 单一继承 | 多重实现(接口继承接口为多重继承) |
    | 方法访问修饰词 | 不能有private | 默认为public，默认方法为default |

* 权限修饰词
    - public 
        + 可修饰类，成员变量，构造方法，方法成员
        + 可在任意一个类中被调用
    - protect
        + 可修饰成员变量，构造方法，方法成员，不可修饰外部类
        + 可被自己、同包的类、它的子类调用
    - default
        + 可修饰类(只能缺省使用)，成员变量，构造方法，方法成员
        + 只能自己、同包中的类调用
        + 只能被同包的类继承
    - private
        + 可修饰成员变量，构造方法，成员方法，不能修饰外部类
        + 只能被自身所调用

* IO中字节流与字符流(java.io)

    |    | 字节流 | 字符流 |
    |:--:|:------:|:------:|
    |父类(都继承于抽象类)|InputStream/OutputStream|Reader/Writer|
    |基本单位|字节(8位一个通用字节)|字符(16位两个字节的Unicode)|

* 关联关系
    - 聚合
        + 表示整体对象拥有部分对象
        + 部分对象可以在整体对象创建之前创建，也可以在整体对象销毁之后销毁
    - 组合
        + 部分对象必须在组合创建的同时或之后创建，在组合销毁之前或同时销毁
        + 部分的生命周期不会超过组合
        + 整体被销毁，部分也会被销毁，整体被复制，部分也会别复制
    - B是A的属性，A关联B
    
* 依赖关系
    - A的对象要完成某一个操作，必须使用B的对象
    - 一种使用关系，特定事物的改变可能会影响到使用该事物的事物
    - 某个对象的功能依赖于另一个对象，但并不持有这个对象的引用
    - B作为A的某个方法的参数存在，A依赖B

* String、StringBuffer、StringBuilder
    - String是不可变的，当一个String再次改变值时，它改变它的引用指向一个新的String
    - StringBuffer和StringBuilder是可变的
    - StringBuffer比StringBuilder在线程上更安全
    - String 与 new String()
        + String在栈区创建String引用，指向String池(独立于栈和堆)，如果池中有值相等的String，则指向这个值
        + new String()会在堆中创建一个新的对象

* 基本类型与引用类型
    - 基本类型：简单数据类型，内置的、不可简化的数据类型

        | 数据类型 | 字节长度 |
        |:-:|:-:|
        |byte|      一个字节(8bit)|
        |short|     短整型，两个字节|
        |int|       整型，四个字节|
        |long|      长整型，八个字节|
        |float|     浮点型，四个字节(有效小数点6-7位)|
        |double|    双精度浮点型，八个字节|
        |char|      字符型，两个字节|
        |boolean|   布尔型，一个字节|

    - 引用类型
        + 复合数据类型通过类或接口进行构造，类提供了控绑数据和方法的方式，可以针对程序外部进行信息隐藏
        + 类、接口、数组都是引用类型
    - 基本类型的存储
        + 直接存储在内存的内存栈上
    - 引用类型的存储
        + 在内存栈中存储引用，在内存堆中存储值，通过引用来找到值
    - 基本数据类型分为布尔类型与数值类型，数值类型分为定点类型和浮点类型，定点类型分为整数类型和字符型
    - 常量表示
    
        | 数据类型 | 表示 |
        |:-:|:-:|
        |byte|nB|
        |short|nS|
        |long|nL|
        |八进制|0n|
        |十进制|0Xn|
        |double|nD|
        |float|nF|

    - 封装类
        + Boolean
        + Short
        + Float
        + Double
        + Byte
        + Int
        + Long
        + Character

* 重载(Overload)与重写(Override)
    - 重载(静态多态性)
        + 让类以统一的方式处理不同类型数据的手段
        + 在类中创建多个具有相同的名字，其具有不同的参数列表和不同的方法体
        + 根据调用方法时传递的参数列表来决定使用哪个方法
        + 可以有不同的访问修饰词
    - 重写(动态多态性)
        + 父类与子类之间的多态性，对父类的方法重新定义
        + 子类中定义的方法与父类相同(方法名、返回值与参数列表都相同)
        + 子类重写方法的访问修饰词不能比父类方法严格

* 栈(stack)、堆(heap)、静态区(staticarea)
    - 栈
        + 每个线程包含一个栈，只保存基础数据类型和其他类型的引用
        + 栈中的数据私有，其他栈无法访问
    - 堆
        + 存储的都是对象本身，不存放基本类型和引用
        + 只有一个堆区被所有的线程共享
    - 静态区/方法区
        + 只有一个静态区被所有线程共享
        + 包含整个程序唯一的元素，static变量、class

* final、finally、finalize
    - final
        + 属性不可变，必须赋初始值，可继承，可覆盖
        + 方法不可重写，可继承，可重载
        + 类不可继承
    - finally
        + 异常处理语句结构的一部分，表示总是执行
    - finalize
        + Object类的一个方法，垃圾回收时会调用被回收对象的此方法，可以覆盖此方法提供垃圾回收时的其他资源回收，例如关闭文件

* 静态变量和实例变量
    - 静态变量(类变量)
        + static 修饰词
        + 从属于类
        + 程序加载类的字节码后，静态变量就被分配空间
        + 可以通过类名来使用
        + 所有对象共有一个静态变量
    - 实例变量
        + 从属于对象
        + 必须创建实例对象，实例变量才会被分配空间
        + 对象私有，每个对象都有一个实例变量，互不影响

* sleep()与yield()
    - sleep()
        + 使调用该方法的线程暂停执行一段时间，让其他线程有机会执行
        + 不释放对象锁
        + 该方法要捕捉异常
    - yield()
        + 不能指定用户暂停多长时间
        + 只能让同优先级的线程有执行的机会

* Java序列化
    - Java对象转化为字节序列的过程
    - 持久化对象
        + JVM运行时，对象才可能存在，要求JVM停止将指定对象转化为字节序列保存，之后还可以还原成对象
        + 序列化保存的是对象的状态(成员变量)，不会关注静态变量
    - RPC(远程过程调用)(包括RMI远程方法调用)，或在网络中传递对象都要用到序列化
    - java.io.Serializable接口
        + 当类实现了这个接口，就可以序列化
        + 它是一个标识接口，接口没有包含任何需要子类实现的抽象方法
        + ObjectOutputStream.writeObject(Serializable ojb)
            * 将对象的状态信息保存到流中，序列化
        + ObjectInputStream.readObject()
            * 从流中读取对象状态信息的操作，反序列化
        + 序列化时，会追踪对象内所包含的所有引用，并保存

* Java面向对象的特征
    - 封装
        + 隐藏对象的属性和实现细节，仅提供公共访问方式
    - 继承
        + 联结类的层次模型，并允许类的重用，提供一个明确的表述共性的方法
        + 对象的一个新类可以从现有的类中派生
        + 派生类可以从它的基类继承方法和实例变量，并且类可以修改或增加新的方法
        + 子类中所有的构造函数都会访问父类无参数构造函数，每一个子类构造函数第一行都默认一条super()语句，因为子类会具备父类的数据，所以要先对父类的数据初始化，当父类没有空参数的构造函数，子类构造函数必须通过this或super指定要访问的构造函数
        + 子类重写父类的方法，权限必须大于父类方法权限
    - 多态
        + 方法的重写、重载与动态连接构成多态性
        + 允许不同类的对象对同一消息作出响应
        + 多态性语言具有灵活、抽象、行为共享、代码共享的优势
        + 动态绑定
            * 执行期间判断引用对象的实际类型，根据其实际类型调用方法

* 垃圾回收机制
    - Java中JVM来处理内存动态分配和垃圾回收
    - 算法
        + 发现无用信息
        + 回收被无用对象占用的内存空间

* JDK、JRE、JVM
    - JDK(Java Development Kit)
        + Java开发工具包
    - JRE(Java Runtime Environment)
        + Java运行环境
    - JVM(Java Virtual Machine)
        + Java虚拟机

* 可变参数
    - 适用于参数个数不确定，类型确定的情况，java把可变参数当成数组处理
    - 可变参数必须位于最后一项
    - void fun(int x,int...y);

* equals()
    - 当比较引用时，==比较的是两者的地址
    - 想要比较对象A和对象B是否相等要使用A.equals(B)

* 构造方法
    - 修饰符不能是abstract、static、final、native、strictfp
    - 构造方法不能通过继承获得

* native
    - native修饰的方法是一个原生态方法，对应的实现不在当前文件，而是在其他语言实现的文件中，Java不能对操作系统底层访问和操作，可以通过JNI接口调用其他语言来实现

* 函数式接口
    - 必须是接口
    - 接口中只有一个需要实现的抽象方法

* 线程的启动方法
    - 一个Java程序启动时，一个线程立即运行，他执行main方法，称为程序的主线程
    - 主线程产生其他线程，最后结束
    - 主线程中启动其他线程使用线程对象的start()方法
    - 不能多次执行start()方法
    - 线程启动后会和其他线程并发执行run()方法
    - start()使该线程变为就绪状态，什么时候运行由操作系统调度

* 随机数(Random类)
    - Random() 创建一个新的随机数生成器
        + Random(long seed)
    - nextInt() 生成一个int值的随机数
        + nextInt(int n) 生成一个[0,n)之间的int
        + nextDouble() 生成一个[0,1,0)之间的double
    - setSeed(long seed) 重置种子数
    - [不重复的随机数](http://paste.ubuntu.com/26208386/)
